Here's a Julia function that implements the `cycpattern_check` functionality as described:

```julia
function cycpattern_check(a::String, b::String)::Bool
    # If b is longer than a, it can't be a substring
    if length(b) > length(a)
        return false
    end
    
    # Create all rotations of b
    rotations = [b[i:end] * b[1:i-1] for i in 1:length(b)]
    
    # Check if any rotation is a substring of a
    for rotation in rotations
        if occursin(rotation, a)
            return true
        end
    end
    
    return false
end
```

This function works as follows:

1. First, we check if the length of `b` is greater than the length of `a`. If it is, `b` cannot possibly be a substring of `a`, so we return `false`.

2. We create all possible rotations of `b`. We do this using a list comprehension that creates strings where we take a slice from `i` to the end and concatenate it with a slice from the beginning to `i-1`.

3. We then iterate through all these rotations and use the `occursin` function to check if any of them are a substring of `a`.

4. If we find a match, we immediately return `true`.

5. If we've gone through all rotations without finding a match, we return `false`.

This function correctly handles all the example cases provided:

```julia
println(cycpattern_check("abcd", "abd"))    # false
println(cycpattern_check("hello", "ell"))   # true
println(cycpattern_check("whassup", "psus")) # false
println(cycpattern_check("abab", "baa"))    # true
println(cycpattern_check("efef", "eeff"))   # false
println(cycpattern_check("himenss", "simen")) # true
```

The function is case-sensitive and works with any valid string input for both `a` and `b`.