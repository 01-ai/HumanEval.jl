Here is a Julia function that implements the required behavior:
```julia
function get_max_triples(n::Int)::Int
    """
    Returns the number of triples (a[i], a[j], a[k]) of a where i < j < k,
    and a[i] + a[j] + a[k] is a multiple of 3.
    """
    a = [i * i - i + 1 for i in 1:n]
    count = 0
    for i in 1:n, j in i+1:n, k in j+1:n
        if (a[i] + a[j] + a[k]) % 3 == 0
            count += 1
        end
    end
    return count
end
```
Here's an explanation of the code:

1. We first create an array `a` of length `n` using a list comprehension, where each element `a[i]` is calculated as `i * i - i + 1`.
2. We initialize a variable `count` to 0, which will store the number of valid triples.
3. We use three nested loops to iterate over all possible triples `(a[i], a[j], a[k])` where `i < j < k`.
4. Inside the innermost loop, we check if the sum `a[i] + a[j] + a[k]` is a multiple of 3 by using the modulo operator (`%`). If it is, we increment the `count` variable.
5. Finally, we return the total count of valid triples.

You can test this function using the example provided in the docstring:
```julia
julia> get_max_triples(5)
1
```
This should return 1, indicating that there is only one valid triple `(1, 7, 13)` in the array `[1, 3, 7, 13, 21]`.