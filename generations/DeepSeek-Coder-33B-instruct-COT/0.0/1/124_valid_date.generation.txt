Here is a Julia function that implements the given problem:

```julia
function valid_date(date::String)::Bool
    # Check if the date string is not empty
    if isempty(date)
        return false
    end

    # Split the date string into month, day, and year
    date_parts = split(date, '-')

    # Check if the date is in the format: mm-dd-yyyy
    if length(date_parts) != 3
        return false
    end

    # Convert the month, day, and year to integers
    month, day, year = tryparse.(Int, date_parts)

    # Check if the month, day, and year are valid
    if month === nothing || day === nothing || year === nothing
        return false
    end

    # Check if the month is valid
    if month < 1 || month > 12
        return false
    end

    # Check if the day is valid
    if day < 1 || day > 31
        return false
    end

    # Check if the day is valid for February
    if month == 2 && (day > 29 || (day == 29 && !isleapyear(year)))
        return false
    end

    # Check if the day is valid for April, June, September, and November
    if month in [4, 6, 9, 11] && day > 30
        return false
    end

    # If all checks pass, the date is valid
    return true
end
```

This function first checks if the date string is not empty and if it is in the correct format. It then splits the date string into month, day, and year and checks if these are valid. It checks if the month is valid and if the day is valid for the given month. If all checks pass, the function returns `true`, otherwise it returns `false`.
