### Step-by-Step Outline

1. **Input Validation**: Check if `x` and `y` are positive integers. If not, return an error or a specific value indicating invalid input. However, since the function signature specifies `x` and `y` as integers, and the task doesn't explicitly require validation of positivity, we'll assume `x` and `y` are always positive for simplicity.

2. **Range Adjustment**: Ensure `x` is less than or equal to `y`. If `x` is greater than `y`, it means there's no range to search for an even number, and the function should return -1.

3. **Find the Largest Even Number**: Starting from `y` and moving downwards, find the first even number in the range `[x, y]`. This can be done by checking if `y` is even by using the modulo operator (`y % 2 == 0`). If `y` is not even, subtract 1 to make it even, ensuring it's still within the range `[x, y]`.

4. **Return the Result**: If an even number is found within the range, return it. If the adjusted even number falls below `x`, it means there are no even numbers in the range, and the function should return -1.

### Julia Code Implementation

```julia
function choose_num(x::Int, y::Int)::Int
    # Step 2: Range Adjustment
    if x > y
        return -1
    end

    # Step 3: Find the Largest Even Number
    # If y is odd, subtract 1 to make it even
    if y % 2 != 0
        y -= 1
    end

    # Check if the adjusted y is still within the range
    if y < x
        return -1
    else
        return y
    end
end
```

This implementation directly follows the outlined steps, ensuring that the function behaves as expected for the given task.