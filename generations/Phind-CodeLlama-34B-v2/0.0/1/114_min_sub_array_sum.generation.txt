

Here is a possible implementation of the `min_sub_array_sum` function in Julia:

```julia
function min_sub_array_sum(nums::Vector{Int})::Int
    min_sum = typemax(Int)
    current_sum = 0

    for num in nums
        current_sum += num
        if current_sum < min_sum
            min_sum = current_sum
        end
        if current_sum > 0
            current_sum = 0
        end
    end

    return min_sum
end
```

This function works by iterating over the input array `nums` and maintaining a running total `current_sum` of the elements. If `current_sum` becomes less than `min_sum`, we update `min_sum` to `current_sum`. If `current_sum` becomes greater than 0, we reset `current_sum` to 0. This is because we are only interested in the minimum sum of non-empty sub-arrays, so if the current sum becomes positive, we know that we can start a new sub-array with a smaller sum.

The time complexity of this function is O(n), where n is the length of the input array, because we are making a single pass over the array. The space complexity is O(1), because we are using a constant amount of space to store the current sum and the minimum sum.