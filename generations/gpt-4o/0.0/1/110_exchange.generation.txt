To solve this problem, we need to determine if we can make all elements in `lst1` even by potentially swapping elements between `lst1` and `lst2`. Here's a step-by-step approach to implement the `exchange` function:

1. **Identify Odd Elements in `lst1`:** First, we need to find all the odd elements in `lst1` because these are the elements that need to be replaced to make `lst1` consist of only even numbers.

2. **Identify Even Elements in `lst2`:** Next, we need to find all the even elements in `lst2` because these are the potential candidates that can replace the odd elements in `lst1`.

3. **Check Feasibility of Exchange:** If the number of odd elements in `lst1` is less than or equal to the number of even elements in `lst2`, then it is possible to make all elements in `lst1` even by exchanging elements. Otherwise, it is not possible.

Here is the implementation of the `exchange` function in Julia:

```julia
function exchange(lst1::Vector{Int}, lst2::Vector{Int})::String
    # Find the number of odd elements in lst1
    odd_count_lst1 = count(x -> x % 2 != 0, lst1)
    
    # Find the number of even elements in lst2
    even_count_lst2 = count(x -> x % 2 == 0, lst2)
    
    # Check if we can replace all odd elements in lst1 with even elements from lst2
    if odd_count_lst1 <= even_count_lst2
        return "YES"
    else
        return "NO"
    end
end
```

### Explanation:
- **Counting Odd Elements in `lst1`:** We use the `count` function with a lambda function `x -> x % 2 != 0` to count how many elements in `lst1` are odd.
- **Counting Even Elements in `lst2`:** Similarly, we use the `count` function with a lambda function `x -> x % 2 == 0` to count how many elements in `lst2` are even.
- **Feasibility Check:** We compare the count of odd elements in `lst1` with the count of even elements in `lst2`. If the former is less than or equal to the latter, we return "YES"; otherwise, we return "NO".

### Example Usage