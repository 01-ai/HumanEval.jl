Here's a Julia function that solves the problem you've described:

```julia
function eat(number::Int, need::Int, remaining::Int)::Vector{Int}
    # Check constraints
    @assert 0 <= number <= 1000 "number must be between 0 and 1000"
    @assert 0 <= need <= 1000 "need must be between 0 and 1000"
    @assert 0 <= remaining <= 1000 "remaining must be between 0 and 1000"

    # Calculate how many carrots the rabbit can actually eat
    eaten = min(need, remaining)

    # Calculate the new total of eaten carrots
    total_eaten = number + eaten

    # Calculate the new remaining carrots
    new_remaining = remaining - eaten

    # Return the result as a vector
    return [total_eaten, new_remaining]
end
```

This function does the following:

1. It first checks if the input values meet the given constraints using `@assert` statements. If any of the constraints are violated, it will throw an error.

2. It calculates how many carrots the rabbit can actually eat. This is the minimum of the number of carrots needed and the number of carrots remaining.

3. It calculates the new total of eaten carrots by adding the number of carrots just eaten to the number of carrots already eaten.

4. It calculates the new number of remaining carrots by subtracting the number of carrots just eaten from the initial number of remaining carrots.

5. Finally, it returns a vector with two elements: the total number of eaten carrots and the number of remaining carrots.

This function will work correctly for all the example cases you provided:

```julia
julia> eat(5, 6, 10)
2-element Vector{Int64}:
 11
  4

julia> eat(4, 8, 9)
2-element Vector{Int64}:
 12
  1

julia> eat(1, 10, 10)
2-element Vector{Int64}:
 11
  0

julia> eat(2, 11, 5)
2-element Vector{Int64}:
 7
 0
```

The function handles all cases, including when there are not enough remaining carrots to satisfy the rabbit's needs. In such cases, the rabbit will eat all remaining carrots, as specified in the problem description.