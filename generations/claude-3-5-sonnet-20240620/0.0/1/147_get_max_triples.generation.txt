Here's a Julia function that solves the problem:

```julia
function get_max_triples(n::Int)::Int
    count = 0
    a = [i * i - i + 1 for i in 1:n]
    
    for i in 1:n-2
        for j in i+1:n-1
            for k in j+1:n
                if (a[i] + a[j] + a[k]) % 3 == 0
                    count += 1
                end
            end
        end
    end
    
    return count
end
```

This function does the following:

1. We initialize a counter `count` to keep track of the number of valid triples.

2. We create the array `a` using a list comprehension, where each element is calculated as `i * i - i + 1` for `i` from 1 to `n`.

3. We use three nested loops to iterate through all possible combinations of `i`, `j`, and `k` where `i < j < k`.

4. For each combination, we check if the sum of `a[i]`, `a[j]`, and `a[k]` is divisible by 3 using the modulo operator `%`.

5. If the sum is divisible by 3, we increment the `count`.

6. Finally, we return the total `count` of valid triples.

This solution has a time complexity of O(n^3) as it checks all possible triples. For small to medium values of `n`, this should work fine. However, for very large values of `n`, a more optimized solution might be necessary.

You can test the function with the example you provided:

```julia
julia> get_max_triples(5)
1
```

This correctly returns 1, as there is only one valid triple (1, 7, 13) in the array [1, 3, 7, 13, 21] where the sum is divisible by 3.