Here's a Julia function that solves the given problem:

```julia
function unique_digits(xs::Vector{Int})::Vector{Int}
    function has_no_even_digits(n::Int)
        while n > 0
            digit = n % 10
            if iseven(digit)
                return false
            end
            n รท= 10
        end
        return true
    end

    result = filter(has_no_even_digits, xs)
    return sort(unique(result))
end
```

This function does the following:

1. We define an inner helper function `has_no_even_digits(n::Int)` that checks if a number has any even digits:
   - It iterates through each digit of the number.
   - If it finds an even digit, it returns `false`.
   - If it goes through all digits without finding an even one, it returns `true`.

2. We use `filter(has_no_even_digits, xs)` to keep only the numbers that have no even digits.

3. We apply `unique()` to remove any duplicates from the filtered list.

4. Finally, we `sort()` the resulting list in ascending order.

5. The function returns this sorted, unique list of numbers with no even digits.

This implementation satisfies all the requirements:
- It works with a list of positive integers.
- It returns a list of elements that don't have any even digits.
- The returned list is sorted in increasing order.
- It handles duplicate values correctly.

You can use this function as follows:

```julia
julia> unique_digits([15, 33, 1422, 1])
3-element Vector{Int64}:
  1
 15
 33

julia> unique_digits([152, 313, 1422, 10])
1-element Vector{Int64}:
 313
```

The function correctly handles the given examples and should work for any input list of positive integers.