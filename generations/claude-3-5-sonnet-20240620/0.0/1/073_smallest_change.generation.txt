Here's a Julia function that solves the problem of finding the minimum number of elements that need to be changed to make an array palindromic:

```julia
function smallest_change(xs::Vector{Int})::Int
    n = length(xs)
    changes = 0
    
    for i in 1:div(n, 2)
        if xs[i] != xs[n-i+1]
            changes += 1
        end
    end
    
    return changes
end
```

This function works as follows:

1. We start by getting the length of the input array `xs` and initializing a counter `changes` to 0.

2. We iterate through the first half of the array (up to `div(n, 2)`). For each index `i`:

   - We compare the element at index `i` with the element at the corresponding position from the end of the array (index `n-i+1`).
   - If these elements are not equal, we increment the `changes` counter.

3. Finally, we return the total number of changes needed.

This approach works because:

- To make an array palindromic, we need to ensure that each element in the first half matches the corresponding element in the second half.
- We only need to check the first half of the array because each change in the first half implicitly fixes the corresponding position in the second half.
- The middle element (if the array has an odd length) doesn't need to be changed, so we don't need to consider it.

This solution has a time complexity of O(n/2), which simplifies to O(n), where n is the length of the input array. The space complexity is O(1) as we only use a constant amount of extra space.

Let's test it with the provided examples:

```julia
julia> smallest_change([1, 2, 3, 5, 4, 7, 9, 6])
4

julia> smallest_change([1, 2, 3, 4, 3, 2, 2])
1

julia> smallest_change([1, 2, 3, 2, 1])
0
```

These results match the expected outputs in the problem statement.