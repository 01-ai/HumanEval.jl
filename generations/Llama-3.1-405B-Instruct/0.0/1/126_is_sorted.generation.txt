Here is a Julia function that implements the `is_sorted` function as described in the docstring:
```julia
function is_sorted(xs::Vector{Int})::Bool
    if length(xs) == 1
        return true
    end

    seen = Set{Int}()
    prev = xs[1]
    for x in xs
        if x in seen
            return false
        end
        if x < prev
            return false
        end
        push!(seen, x)
        prev = x
    end
    return true
end
```
Here's an explanation of the implementation:

1. If the input vector has only one element, it is considered sorted, so we return `true`.
2. We create an empty set `seen` to keep track of the numbers we've seen so far.
3. We iterate through the input vector, keeping track of the previous element `prev`.
4. For each element `x`, we check if it's already in the `seen` set. If it is, it means we've seen this number before, so we return `false`.
5. We also check if `x` is less than the previous element `prev`. If it is, it means the list is not sorted, so we return `false`.
6. If `x` passes both checks, we add it to the `seen` set and update the `prev` variable.
7. If we reach the end of the loop without returning `false`, it means the list is sorted, so we return `true`.

You can test this function using the examples provided in the docstring:
```julia
println(is_sorted([5]))  # true
println(is_sorted([1, 2, 3, 4, 5]))  # true
println(is_sorted([1, 3, 2, 4, 5]))  # false
println(is_sorted([1, 2, 3, 4, 5, 6]))  # true
println(is_sorted([1, 2, 3, 4, 5, 6, 7]))  # true
println(is_sorted([1, 3, 2, 4, 5, 6, 7]))  # false
println(is_sorted([1, 2, 2, 3, 3, 4]))  # false
println(is_sorted([1, 2, 2, 2, 3, 4]))  # false
```