To implement the `compare_one` function, we will follow these steps:

1. Define the function `compare_one` with the appropriate type annotations for the parameters `a` and `b`.
2. Convert both `a` and `b` to floats for comparison, taking into account that strings may use either `.` or `,` as the decimal separator.
3. Compare the float representations of `a` and `b`.
4. If `a` is greater, return `a` in its original type.
5. If `b` is greater, return `b` in its original type.
6. If `a` and `b` are equal, return `nothing`.
7. Write test cases to validate the function against the provided examples.

Now, let's write the code for the `compare_one` function:

```julia
function compare_one(a::Union{Integer, AbstractFloat, AbstractString}, b::Union{Integer, AbstractFloat, AbstractString})::Union{Integer, AbstractFloat, AbstractString, Nothing}
    # Step 2: Convert both `a` and `b` to floats for comparison
    float_a = parse(Float64, replace(string(a), ',' => '.'))
    float_b = parse(Float64, replace(string(b), ',' => '.'))

    # Step 3: Compare the float representations of `a` and `b`
    if float_a > float_b
        # Step 4: Return `a` in its original type
        return a
    elseif float_b > float_a
        # Step 5: Return `b` in its original type
        return b
    else
        # Step 6: If `a` and `b` are equal, return `nothing`
        return nothing
    end
end

# Step 7: Test cases
println(compare_one(1, 2.5)) # Should print 2.5
println(compare_one(1, "2,3")) # Should print "2,3"
println(compare_one("5,1", "6")) # Should print "6"
println(compare_one("1", 1)) # Should print nothing
```

Please note that the function assumes that the strings represent valid real numbers and does not handle invalid input or edge cases such as non-numeric strings.