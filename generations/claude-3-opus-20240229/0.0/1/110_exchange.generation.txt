Here's a Julia implementation for the `exchange` function:

```julia
function exchange(lst1::Vector{Int}, lst2::Vector{Int})::String
    # Create a set of odd numbers from lst1
    odd_nums = Set(num for num in lst1 if isodd(num))

    # Check if all odd numbers in lst1 can be replaced with even numbers from lst2
    for odd_num in odd_nums
        if !any(iseven(num) && num ∉ odd_nums for num in lst2)
            return "NO"
        end
    end

    return "YES"
end
```

Here's how the function works:

1. First, we create a set `odd_nums` containing all the odd numbers from `lst1`.
2. Then, we loop through each odd number `odd_num` in `odd_nums`.
3. For each `odd_num`, we check if there exists an even number in `lst2` that is not already present in `odd_nums`. This is done using the `any` function with the condition `iseven(num) && num ∉ odd_nums`.
4. If there is no such even number in `lst2`, we return `"NO"` since it's not possible to make all elements in `lst1` even.
5. If the loop completes without returning `"NO"`, it means that all odd numbers in `lst1` can be replaced with even numbers from `lst2`, so we return `"YES"`.

Here are some test cases:

```jldoctest
julia> exchange([1, 2, 3, 4], [1, 2, 3, 4])
"YES"

julia> exchange([1, 2, 3, 4], [1, 5, 3, 4])
"NO"

julia> exchange([1, 3, 5], [2, 4, 6])
"YES"

julia> exchange([1, 3, 5], [2, 4])
"NO"
```

Note that this implementation assumes that the input lists will be non-empty, as mentioned in the problem statement.