Here is a Julia function that implements the described behavior:

```julia
function intersection(interval1::Vector{Int}, interval2::Vector{Int})::String
    # Check if intervals intersect
    if interval1[2] < interval2[1] || interval2[2] < interval1[1]
        return "NO"
    end

    # Calculate intersection
    intersection_start = max(interval1[1], interval2[1])
    intersection_end = min(interval1[2], interval2[2])

    # Calculate length of intersection
    intersection_length = intersection_end - intersection_start + 1

    # Check if length of intersection is prime
    if intersection_length < 2
        return "NO"
    end

    for i in 2:isqrt(intersection_length)
        if intersection_length % i == 0
            return "NO"
        end
    end

    return "YES"
end
```

This function first checks if the intervals intersect. If they don't, it returns "NO". If they do, it calculates the start and end of the intersection, and the length of the intersection. It then checks if the length of the intersection is a prime number. If it is, it returns "YES". If it isn't, it returns "NO".