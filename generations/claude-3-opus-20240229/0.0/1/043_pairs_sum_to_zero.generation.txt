Here's an implementation of the `pairs_sum_to_zero` function in Julia:

```julia
function pairs_sum_to_zero(l::Vector{Int})::Bool
    n = length(l)
    for i in 1:n-1
        for j in i+1:n
            if l[i] + l[j] == 0
                return true
            end
        end
    end
    return false
end
```

Explanation:

1. The function takes a vector of integers `l` as input and returns a boolean value.

2. We start by finding the length of the vector `l` and store it in the variable `n`.

3. We use two nested loops to iterate over all possible pairs of distinct elements in the vector.
   - The outer loop `for i in 1:n-1` iterates from index 1 to `n-1` (inclusive).
   - The inner loop `for j in i+1:n` iterates from index `i+1` to `n` (inclusive). This ensures that we only consider pairs where `j > i`, avoiding duplicate pairs and self-pairs.

4. Inside the inner loop, we check if the sum of elements at indices `i` and `j` is equal to zero (`l[i] + l[j] == 0`).
   - If the sum is equal to zero, we have found a pair of distinct elements that sum to zero, so we immediately return `true`.

5. If we complete both loops without finding a pair that sums to zero, it means no such pair exists in the vector. In this case, we return `false`.

The time complexity of this implementation is O(n^2) since we have two nested loops iterating over the elements of the vector. The space complexity is O(1) as we only use a constant amount of extra space.

The given implementation correctly handles the provided test cases:

```julia
julia> pairs_sum_to_zero([1, 3, 5, 0])
false

julia> pairs_sum_to_zero([1, 3, -2, 1])
false

julia> pairs_sum_to_zero([1, 2, 3, 7])
false

julia> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])
true

julia> pairs_sum_to_zero([1])
false
```

I hope this helps! Let me know if you have any further questions.