  Here is an implementation of the `compare_one` function in Julia, based on the given docstring:
```
function compare_one(a::Union{Integer, AbstractFloat, AbstractString}, b::Union{Integer, AbstractFloat, AbstractString})::Union{Integer, AbstractFloat, AbstractString, Nothing}
    # Convert strings to floats if necessary
    if typeof(a) == AbstractString
        a = parse(Float64, a)
    end
    if typeof(b) == AbstractString
        b = parse(Float64, b)
    end

    # Compare the values
    if a > b
        return a
    elseif a < b
        return b
    else
        return nothing
    end
end
```
Here's an explanation of the code:

1. The function takes two arguments, `a` and `b`, which can be integers, floats, or strings representing real numbers.
2. The function checks if the arguments are strings, and if so, it converts them to floats using the `parse` function.
3. The function then compares the values of `a` and `b` using the `>` and `<` operators. If `a` is greater than `b`, the function returns `a`. If `b` is greater than `a`, the function returns `b`. If the values are equal, the function returns `nothing`.

Note that the function returns the larger value in its given variable type, so if `a` and `b` are both integers, the function will return an integer. If `a` and `b` are both floats, the function will return a float. If `a` and `b` are both strings, the function will return a string.