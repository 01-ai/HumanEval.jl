function min_path(grid::Vector{Vector{Int}}, k::Int)::Vector{Int}
    N = length(grid)
    if N < 2
        throw(ArgumentError("Grid must have at least 2 rows and 2 columns."))
    end

    # Initialize the minimum path with the first cell's value
    min_path = [typemax(Int)]

    # Define a helper function to check if a move is valid
    function is_valid(row, col)
        return 1 <= row <= N && 1 <= col <= N
    end

    # Define a helper function to get the neighbors of a cell
    function get_neighbors(row, col)
        neighbors = []
        for dr = -1:1, dc = -1:1
            if dr != 0 || dc != 0  # Exclude the current cell
                new_row, new_col = row + dr, col + dc
                if is_valid(new_row, new_col)
                    push!(neighbors, (new_row, new_col))
                end
            end
        end
        return neighbors
    end

    # Define a recursive function to explore paths
    function explore_path(row, col, path, depth)
        if depth == k
            # If the current path is lexicographically less than the current minimum, update it
            if path < min_path
                global min_path = path
            end
            return
        end

        # Explore neighbors
        for (new_row, new_col) in get_neighbors(row, col)
            new_path = vcat(path, grid[new_row][new_col])
            explore_path(new_row, new_col, new_path, depth + 1)
        end
    end

    # Start exploring from each cell
    for i in 1:N, j in 1:N
        explore_path(i, j, [grid[i][j]], 1)
    end

    return min_path
end

# Example usage
# grid = [[1, 2, 3