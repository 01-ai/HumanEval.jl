### Step-by-Step Outline:

1. Define the function `numerical_letter_grade` that takes a vector of floating-point numbers `grades` as an argument.
2. Create a mapping from GPA ranges to letter grades according to the provided table.
3. Initialize an empty vector of strings to store the letter grades.
4. Iterate over each GPA in the `grades` vector.
5. For each GPA, determine the corresponding letter grade by comparing it to the GPA ranges in the mapping.
6. Append the determined letter grade to the vector of letter grades.
7. Return the vector of letter grades after all GPAs have been processed.

### Julia Code:

```julia
function numerical_letter_grade(grades::Vector{Float64})::Vector{String}
    # Mapping from GPA to letter grades
    grade_mapping = Dict(
        4.0 => "A+",
        3.7 => "A",
        3.3 => "A-",
        3.0 => "B+",
        2.7 => "B",
        2.3 => "B-",
        2.0 => "C+",
        1.7 => "C",
        1.3 => "C-",
        1.0 => "D+",
        0.7 => "D",
        0.0 => "D-",
        -Inf => "E"
    )

    # Initialize an empty vector for letter grades
    letter_grades = String[]

    # Iterate over the grades and determine the letter grade
    for gpa in grades
        for (threshold, letter) in sort(collect(grade_mapping), by=x->x[1], rev=true)
            if gpa > threshold
                push!(letter_grades, letter)
                break
            end
        end
    end

    return letter_grades
end
```

This function will iterate over the `grades` vector, compare each GPA to the thresholds in the `grade_mapping` dictionary, and append the corresponding letter grade to the `letter_grades` vector. The `sort` function is used to ensure that the mapping is checked in descending order of GPA thresholds. The `push!` function appends the letter grade to the `letter_grades` vector, and the `break` statement exits the inner loop once the correct letter grade is found.