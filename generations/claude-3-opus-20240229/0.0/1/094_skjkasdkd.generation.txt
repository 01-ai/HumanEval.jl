Here's a Julia function that solves the problem:

```julia
function is_prime(n::Int)
    if n < 2
        return false
    end
    for i in 2:isqrt(n)
        if n % i == 0
            return false
        end
    end
    return true
end

function sum_digits(n::Int)
    sum = 0
    while n > 0
        sum += n % 10
        n = n รท 10
    end
    return sum
end

function skjkasdkd(xs::Vector{Int})::Int
    largest_prime = 0
    for x in xs
        if is_prime(x) && x > largest_prime
            largest_prime = x
        end
    end
    return sum_digits(largest_prime)
end
```

Here's how it works:

1. The `is_prime` function checks if a given number `n` is prime or not. It returns `true` if `n` is prime, and `false` otherwise.
2. The `sum_digits` function calculates the sum of digits of a given number `n`.
3. The `skjkasdkd` function takes a vector of integers `xs` as input. It iterates over each element `x` in `xs` and checks if `x` is prime and larger than the current `largest_prime`. If so, it updates `largest_prime` to `x`. After iterating over all elements, it returns the sum of digits of `largest_prime`.

Here are some examples:

```jldoctest
julia> skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])
10

julia> skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])
25

julia> skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])
13

julia> skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])
11

julia> skjkasdkd([0, 81, 12, 3, 1, 21])
3

julia> skjkasdkd([0, 8, 1, 2, 1, 7])
7
```