

To solve this problem, we will first split the input string by the delimiter "-" to get the day, month, and year. Then, we will check if the day, month, and year are within the valid ranges. We will also check if the date string follows the correct format.

Here is the step-by-step outline:

1. Check if the date string is empty. If it is, return false.
2. Split the date string by the delimiter "-".
3. Check if the length of the split array is 3. If it's not, return false.
4. Convert the month and day to integers.
5. Check if the month is between 1 and 12. If it's not, return false.
6. Check if the day is between 1 and the maximum number of days in the given month. If it's not, return false.
7. Check if the year is a leap year or not. If it is, the maximum number of days in February is 29. Otherwise, it is 28.
8. Return true if all the checks pass, otherwise return false.

Here is the Julia code:

```julia
function valid_date(date::String)::Bool
    # Check if the date string is empty
    if date == ""
        return false
    end

    # Split the date string by the delimiter "-"
    date_parts = split(date, "-")

    # Check if the length of the split array is 3
    if length(date_parts) != 3
        return false
    end

    # Convert the month and day to integers
    month = parse(Int, date_parts[1])
    day = parse(Int, date_parts[2])

    # Check if the month is between 1 and 12
    if month < 1 || month > 12
        return false
    end

    # Check if the day is between 1 and the maximum number of days in the given month
    if day < 1 || day > 31
        return false
    end

    # Check if the year is a leap year or not
    year = parse(Int, date_parts[3])
    if year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)
        if day > 29
            return false
        end
    else
        if day > 28
            return false
        end
    end

    # Return true if all the checks pass
    return true
end
```

This function will return true if the given date string is valid and false otherwise.