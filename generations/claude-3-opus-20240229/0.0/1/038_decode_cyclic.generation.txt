To decode the string encoded by the `encode_cyclic` function, we need to reverse the process. Here's the implementation of the `decode_cyclic` function:

```julia
function decode_cyclic(s::String)::String
    result = ""
    for i in 1:3:length(s)
        if i + 2 <= length(s)
            result *= s[i+1] * s[i+2] * s[i]
        else
            result *= s[i:end]
        end
    end
    return result
end
```

Explanation:
1. We initialize an empty string called `result` to store the decoded string.

2. We iterate over the encoded string `s` in steps of 3 using a `for` loop. The loop variable `i` represents the starting index of each group of three characters.

3. Inside the loop, we check if there are at least three characters remaining in the string starting from index `i`. If so, we concatenate the characters at indices `i+1`, `i+2`, and `i` (in that order) to the `result` string.

4. If there are fewer than three characters remaining, it means we have reached the end of the string. In this case, we simply concatenate the remaining characters (from index `i` to the end) to the `result` string.

5. After the loop ends, we return the `result` string, which contains the decoded version of the input string.

The `decode_cyclic` function reverses the encoding process by rearranging the characters in each group of three. If the original string had a length not divisible by 3, the remaining characters are left unchanged.

Here's an example usage:

```julia
encoded_str = encode_cyclic("Hello, World!")
println(encoded_str)  # Output: "elHo,lW odr!"

decoded_str = decode_cyclic(encoded_str)
println(decoded_str)  # Output: "Hello, World!"
```

The `decode_cyclic` function successfully decodes the string encoded by `encode_cyclic`, restoring it to its original form.