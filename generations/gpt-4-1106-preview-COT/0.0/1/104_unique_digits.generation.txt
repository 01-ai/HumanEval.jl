To implement the `unique_digits` function, we will follow these steps:

1. Define the function `unique_digits` that takes a vector of integers `xs` as input.
2. Initialize an empty vector `result` to store the numbers that meet the criteria.
3. Iterate over each number in the input vector `xs`.
4. For each number, convert it to a string and check if it contains any even digit.
5. If the number does not contain any even digit, add it to the `result` vector.
6. After processing all numbers, sort the `result` vector in increasing order.
7. Return the sorted `result` vector.

Now, let's write the code for the function:

```julia
function unique_digits(xs::Vector{Int})::Vector{Int}
    # Step 2: Initialize an empty vector to store the numbers without even digits
    result = Int[]

    # Step 3: Iterate over each number in the input vector
    for x in xs
        # Step 4: Convert the number to a string and check for even digits
        has_even_digit = any(digit -> iseven(parse(Int, digit)), string(x))
        
        # Step 5: If the number does not contain any even digit, add it to the result
        if !has_even_digit
            push!(result, x)
        end
    end

    # Step 6: Sort the result vector in increasing order
    sort!(result)

    # Step 7: Return the sorted result vector
    return result
end
```

Let's test the function with the provided examples to ensure it works as expected:

```julia
println(unique_digits([15, 33, 1422, 1])) # Should print [1, 15, 33]
println(unique_digits([152, 313, 1422, 10])) # Should print [313]
```

Please note that the function assumes that all elements in the input vector are positive integers, as stated in the docstring. If the input may contain non-positive integers, additional validation should be added.