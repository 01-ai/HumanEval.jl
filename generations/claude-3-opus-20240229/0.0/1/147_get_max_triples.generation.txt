Here's a solution to the problem in Julia:

```julia
function get_max_triples(n::Int)::Int
    a = [i^2 - i + 1 for i in 1:n]
    count = 0
    
    for i in 1:n-2
        for j in i+1:n-1
            for k in j+1:n
                if (a[i] + a[j] + a[k]) % 3 == 0
                    count += 1
                end
            end
        end
    end
    
    return count
end
```

Explanation:

1. We create the array `a` using a list comprehension. Each element `a[i]` is calculated as `i^2 - i + 1` for `i` ranging from 1 to `n`.

2. We initialize a variable `count` to keep track of the number of valid triples.

3. We use three nested loops to iterate over all possible combinations of indices `i`, `j`, and `k` where `i < j < k`.

4. For each combination of indices, we check if the sum `a[i] + a[j] + a[k]` is divisible by 3 using the modulo operator `%`. If it is, we increment the `count` by 1.

5. Finally, we return the `count` of valid triples.

Let's test the function with the example:

```jldoctest
julia> get_max_triples(5)  # a = [1, 3, 7, 13, 21] The only valid triple is (1, 7, 13).
1
```

The time complexity of this solution is O(n^3) since we have three nested loops iterating over the elements of the array. The space complexity is O(n) for creating the array `a`.

Note: This solution may not be efficient for very large values of `n` due to the cubic time complexity. For such cases, more optimized approaches or mathematical insights might be needed to improve the efficiency.