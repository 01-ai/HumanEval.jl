 Here's the implementation of the `compare_one` function in Julia:

```julia
function compare_one(a::Union{Integer, AbstractFloat, AbstractString}, b::Union{Integer, AbstractFloat, AbstractString})::Union{Integer, AbstractFloat, AbstractString, Nothing}
    # Helper function to convert strings to floats, handling both '.' and ',' as decimal separators
    function parse_number(s::AbstractString)
        try
            return parse(Float64, replace(s, ',' => '.'))
        catch e
            throw(ArgumentError("Invalid number format in string"))
        end
    end

    # Convert inputs to floats if they are strings
    a_num = typeof(a) <: AbstractString ? parse_number(a) : a
    b_num = typeof(b) <: AbstractString ? parse_number(b) : b

    # Compare the numbers
    if a_num > b_num
        return a
    elseif b_num > a_num
        return b
    else
        return nothing
    end
end
```

This function first defines a helper function `parse_number` to handle the conversion of strings to floats, allowing for both `.` and `,` as decimal separators. It then converts the inputs to floats if they are strings and compares them. If `a` is greater than `b`, it returns `a`; if `b` is greater than `a`, it returns `b`; if they are equal, it returns `nothing`.