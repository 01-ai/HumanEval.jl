Here's a Julia function that implements the `rescale_to_unit` operation as described:

```julia
function rescale_to_unit(numbers::Vector{Float64})::Vector{Float64}
    if length(numbers) < 2
        throw(ArgumentError("Input vector must have at least two elements"))
    end

    min_val = minimum(numbers)
    max_val = maximum(numbers)
    
    if min_val == max_val
        throw(ArgumentError("All numbers in the input are identical; cannot rescale"))
    end

    return [(x - min_val) / (max_val - min_val) for x in numbers]
end
```

This function does the following:

1. It first checks if the input vector has at least two elements. If not, it throws an `ArgumentError`.

2. It finds the minimum and maximum values in the input vector.

3. It checks if all numbers in the input are identical (i.e., min_val == max_val). If they are, it throws an `ArgumentError` because it's impossible to rescale in this case.

4. It applies the linear transformation to each number in the input vector:
   - It subtracts the minimum value from each number to shift the range to start at 0.
   - It then divides by the range (max_val - min_val) to scale the values between 0 and 1.

5. The result is returned as a new vector of the same length as the input, with values rescaled between 0 and 1.

This implementation ensures that the smallest number becomes 0 and the largest becomes 1, with all other numbers linearly scaled in between.

You can use this function like this:

```julia
julia> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])
5-element Vector{Float64}:
 0.0
 0.25
 0.5
 0.75
 1.0

julia> rescale_to_unit([10.0, 20.0, 30.0, 40.0, 50.0])
5-element Vector{Float64}:
 0.0
 0.25
 0.5
 0.75
 1.0

julia> rescale_to_unit([-10.0, 0.0, 10.0])
3-element Vector{Float64}:
 0.0
 0.5
 1.0
```

This function handles various input ranges and scales them appropriately to the [0, 1] range.