To implement the `max_fill` function in Julia, we need to count the total number of `1`s in the grid and then determine how many times we need to lower the bucket to remove all the water, given the bucket's capacity.

Here's the step-by-step approach:

1. **Count the total number of `1`s in the grid**: This represents the total units of water.
2. **Calculate the number of bucket operations needed**: Divide the total units of water by the bucket capacity and round up to account for any remaining water that doesn't fill a whole bucket.

Let's implement this in Julia:

```julia
function max_fill(grid::Vector{Vector{Int}}, capacity::Int)::Int
    # Count the total number of 1s in the grid
    total_water = sum(sum(row) for row in grid)
    
    # Calculate the number of bucket operations needed
    # We use `ceil` to round up the division result
    return ceil(Int, total_water / capacity)
end
```

### Explanation:
- `sum(sum(row) for row in grid)`: This nested sum first sums each row to get the number of `1`s in each row, and then sums these results to get the total number of `1`s in the grid.
- `ceil(Int, total_water / capacity)`: This calculates the number of times we need to lower the bucket. The `ceil` function ensures that any remaining water that doesn't fill a whole bucket still counts as an additional operation.

### Examples:
Let's test the function with the provided examples:

```julia
println(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1))  # Output: 6
println(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2))  # Output: 5
println(max_fill([[0, 0, 0], [0, 0, 0]], 5))  # Output: 0
```

This implementation should correctly handle the given constraints and examples.