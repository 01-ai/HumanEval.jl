To implement the `count_up_to` function in Julia, we need to create a function that generates a list of prime numbers less than a given non-negative integer `n`. Here's how we can do it:

1. Define a helper function to check if a number is prime.
2. Iterate through numbers from 2 up to `n-1` and collect the prime numbers.
3. Return the collected prime numbers as a vector.

Here's the implementation:

```julia
function is_prime(num::Int)::Bool
    if num <= 1
        return false
    elseif num <= 3
        return true
    elseif num % 2 == 0 || num % 3 == 0
        return false
    end
    i = 5
    while i * i <= num
        if num % i == 0 || num % (i + 2) == 0
            return false
        end
        i += 6
    end
    return true
end

function count_up_to(n::Int)::Vector{Int}
    primes = Int[]
    for i in 2:n-1
        if is_prime(i)
            push!(primes, i)
        end
    end
    return primes
end
```

### Explanation:

1. **is_prime Function**:
   - This function checks if a number is prime.
   - It handles small numbers directly and uses a loop to check divisibility for larger numbers.

2. **count_up_to Function**:
   - This function initializes an empty array `primes`.
   - It iterates from 2 to `n-1` and uses the `is_prime` function to check if the current number is prime.
   - If a number is prime, it is added to the `primes` array.
   - Finally, the function returns the `primes` array.

### Example Usage:

```julia
println(count_up_to(5))   # Output: [2, 3]
println(count_up_to(11))  # Output: [2, 3, 5, 7]
println(count_up_to(0))   # Output: []
println(count_up_to(20))  # Output: [2, 3, 5, 7, 11, 13, 17, 19]
println(count_up_to(1))   # Output: []
println(count_up_to(18))  # Output: [2, 