### Outline for Implementing `even_odd_count` Function

1. **Initialize Counters**: Start by initializing two variables, `even_count` and `odd_count`, to zero. These will keep track of the number of even and odd digits, respectively.

2. **Handle Negative Numbers**: Since the function should work for both positive and negative integers, convert the input number to its absolute value. This ensures that the sign of the number does not affect the digit count.

3. **Extract and Count Digits**:
    - Convert the absolute number to a string or iterate through each digit using a loop.
    - For each digit, determine if it is even or odd.
        - If the digit is even, increment `even_count`.
        - If the digit is odd, increment `odd_count`.

4. **Return the Counts**: Once all digits have been evaluated, return the counts as a tuple in the format `(even_count, odd_count)`.

### Julia Code Implementation

```julia
function even_odd_count(num::Int)::Tuple{Int, Int}
    # Initialize counters for even and odd digits
    even_count = 0
    odd_count = 0

    # Convert num to its absolute value to handle negative numbers
    num = abs(num)

    # Iterate through each digit of the number
    while num > 0
        digit = num % 10  # Extract the last digit
        if digit % 2 == 0
            even_count += 1  # Increment even counter if digit is even
        else
            odd_count += 1  # Increment odd counter if digit is odd
        end
        num = div(num, 10)  # Remove the last digit from num
    end

    # Return the counts as a tuple
    return (even_count, odd_count)
end
```

This implementation follows the outlined steps to accurately count the number of even and odd digits in the given integer and return the counts as a tuple.