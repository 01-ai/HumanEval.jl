Here's a Julia function that implements the `is_happy` functionality as described:

```julia
function is_happy(s::String)::Bool
    # Check if the string length is at least 3
    if length(s) < 3
        return false
    end
    
    # Iterate through the string, checking each group of 3 consecutive letters
    for i in 1:(length(s) - 2)
        if s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]
            return false
        end
    end
    
    # If we've made it through all checks, the string is happy
    return true
end
```

This function does the following:

1. First, it checks if the length of the input string is at least 3. If not, it immediately returns `false`.

2. If the string is long enough, it then iterates through the string, checking each group of 3 consecutive letters.

3. For each group of 3 letters, it checks if any two of them are the same. If so, it returns `false`.

4. If it makes it through all checks without finding any repeated letters in groups of 3, it returns `true`.

This implementation should correctly handle all the example cases provided:

```julia
julia> is_happy("a")
false

julia> is_happy("aa")
false

julia> is_happy("abcd")
true

julia> is_happy("aabb")
false

julia> is_happy("adb")
true

julia> is_happy("xyy")
false
```

The function correctly identifies "happy" strings (where every group of 3 consecutive letters are distinct) and "unhappy" strings (where the string is too short or contains repeated letters in groups of 3).