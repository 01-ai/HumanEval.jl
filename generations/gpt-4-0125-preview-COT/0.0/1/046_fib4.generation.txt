### Step-by-Step Outline

1. **Initialize Variables**: Since the function should not use recursion, we will initialize four variables to store the values of `fib4(0)`, `fib4(1)`, `fib4(2)`, and `fib4(3)` which are `0`, `0`, `2`, and `0` respectively. These variables will be used to calculate subsequent `fib4` values iteratively.

2. **Handle Base Cases**: Before proceeding with the general calculation, check if `n` is less than or equal to 3. If so, return the corresponding base case value directly.

3. **Iterative Calculation**: For `n > 3`, use a loop to calculate `fib4(n)` iteratively. In each iteration, calculate the current `fib4` value as the sum of the previous four `fib4` values. Update the variables that store these four values accordingly for the next iteration.

4. **Return Result**: After completing the iterations, return the last calculated `fib4` value as the result.

### Julia Code Implementation

```julia
function fib4(n::Int)::Int
    # Base cases
    if n == 0
        return 0
    elseif n == 1
        return 0
    elseif n == 2
        return 2
    elseif n == 3
        return 0
    end

    # Initialize variables for fib4(0), fib4(1), fib4(2), and fib4(3)
    a, b, c, d = 0, 0, 2, 0

    # Iteratively calculate fib4(n)
    for i in 4:n
        temp = a + b + c + d
        a, b, c = b, c, d  # Shift the last three values
        d = temp  # Update the last value with the new calculation
    end

    return d  # The last calculated value is fib4(n)
end
```

This implementation efficiently computes the `n`-th element of the `fib4` sequence without using recursion, following the iterative approach outlined above.