To implement the `largest_divisor` function, we will follow these steps:

1. Check if the input `n` is an integer greater than 1. If `n` is 1 or less, return an error message since 1 and non-positive numbers do not have a divisor other than themselves.
2. Start a loop from `n-1` down to 2 (since the largest divisor smaller than `n` cannot be `n` itself or greater than `n-1`).
3. In each iteration, check if the current number divides `n` evenly (i.e., `n` modulo the current number is 0).
4. If an even divisor is found, return it as it will be the largest one due to the loop starting from `n-1` and going downwards.
5. If no divisors are found (which should not happen for `n > 1`), return 1 as a fallback, although this case should not occur.

Now, let's write the code for the function:

```julia
function largest_divisor(n::Int)::Int
    # Step 1: Check if n is greater than 1
    if n <= 1
        error("Input must be an integer greater than 1")
    end
    
    # Step 2: Loop from n-1 down to 2 to find the largest divisor
    for i in n-1:-1:2
        # Step 3: Check if i divides n evenly
        if n % i == 0
            # Step 4: Return the divisor if found
            return i
        end
    end
    
    # Step 5: Return 1 as a fallback, although this should not be reached for n > 1
    return 1
end
```

Let's test the function with the provided example:

```julia
println(largest_divisor(15))  # Should print 5
```