Here is a Julia function that implements the behavior described in the docstring:
```julia
function intersection(interval1::Vector{Int}, interval2::Vector{Int})::String
    # Calculate the intersection of the two intervals
    start = max(interval1[1], interval2[1])
    end_ = min(interval1[2], interval2[2])

    # Check if the intervals intersect
    if start > end_
        return "NO"
    end

    # Calculate the length of the intersection
    length = end_ - start + 1

    # Check if the length is a prime number
    is_prime = true
    if length < 2
        is_prime = false
    elseif length == 2
        is_prime = true
    else
        for i in 2:isqrt(length)
            if length % i == 0
                is_prime = false
                break
            end
        end
    end

    # Return "YES" if the length is prime, "NO" otherwise
    return is_prime ? "YES" : "NO"
end
```
Here's an explanation of the code:

1. We first calculate the intersection of the two intervals by finding the maximum of the start points and the minimum of the end points.
2. We check if the intervals intersect by checking if the start point is less than or equal to the end point. If not, we return "NO".
3. We calculate the length of the intersection by subtracting the start point from the end point and adding 1.
4. We check if the length is a prime number by checking if it's less than 2 (in which case it's not prime), or if it's 2 (in which case it is prime). Otherwise, we check if it has any divisors other than 1 and itself by iterating up to the square root of the length.
5. Finally, we return "YES" if the length is prime, and "NO" otherwise.

You can test this function using the examples provided in the docstring:
```julia
println(intersection([1, 2], [2, 3]))  # "NO"
println(intersection([-1, 1], [0, 4]))  # "NO"
println(intersection([-3, -1], [-5, 5]))  # "YES"
```