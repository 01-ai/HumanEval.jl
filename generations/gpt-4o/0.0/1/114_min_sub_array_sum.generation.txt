To implement the `min_sub_array_sum` function in Julia, we can use a variation of Kadane's algorithm, which is typically used to find the maximum sum of a sub-array. Instead of finding the maximum sum, we will modify the algorithm to find the minimum sum of any non-empty sub-array.

Here is the implementation:

```julia
function min_sub_array_sum(nums::Vector{Int})::Int
    # Initialize the minimum sum to the first element
    min_sum = nums[0]
    # Initialize the current sum to the first element
    current_sum = nums[0]
    
    # Iterate through the array starting from the second element
    for i in 2:length(nums)
        # Update the current sum to be the minimum of the current element
        # or the current sum plus the current element
        current_sum = min(nums[i], current_sum + nums[i])
        # Update the minimum sum if the current sum is smaller
        min_sum = min(min_sum, current_sum)
    end
    
    return min_sum
end

# Example usage
println(min_sub_array_sum([2, 3, 4, 1, 2, 4]))  # Output: 1
println(min_sub_array_sum([-1, -2, -3]))        # Output: -6
```

### Explanation:
1. **Initialization**:
   - `min_sum` is initialized to the first element of the array. This will hold the minimum sum found so far.
   - `current_sum` is also initialized to the first element. This will hold the sum of the current sub-array being considered.

2. **Iteration**:
   - We iterate through the array starting from the second element.
   - For each element, we update `current_sum` to be the minimum of the current element itself or the sum of the current element and the `current_sum`. This ensures that we are considering the smallest possible sub-array sum ending at the current element.
   - We then update `min_sum` to be the minimum of `min_sum` and `current_sum`.

3. **Return**:
   - Finally, we return `min_sum`, which contains the minimum sum of any non-empty sub-array.

This approach ensures that we efficiently find the minimum sub-array sum in linear time, O(n), where n is the length of the input array.