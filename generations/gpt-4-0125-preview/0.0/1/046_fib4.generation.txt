To implement the `fib4` function efficiently without using recursion, we can use a dynamic programming approach. This approach involves storing the results of the previous computations in an array and using these results to compute the next elements in the sequence. This way, we avoid the exponential time complexity that comes with the naive recursive solution.

Here's how you can implement the `fib4` function in Julia:

```julia
function fib4(n::Int)::Int
    # Base cases
    if n == 0
        return 0
    elseif n == 1
        return 0
    elseif n == 2
        return 2
    elseif n == 3
        return 0
    end

    # Initialize an array to store the sequence values up to n
    fib4_values = zeros(Int, n + 1)
    fib4_values[1] = 0
    fib4_values[2] = 0
    fib4_values[3] = 2
    fib4_values[4] = 0

    # Compute the sequence values from 5 to n
    for i in 5:n+1
        fib4_values[i] = fib4_values[i-1] + fib4_values[i-2] + fib4_values[i-3] + fib4_values[i-4]
    end

    return fib4_values[n+1]
end
```

This function first handles the base cases for `n = 0`, `n = 1`, `n = 2`, and `n = 3`. Then, it initializes an array `fib4_values` to store the computed values of the sequence up to `n`. It fills in the base cases in this array and iterates from `5` to `n+1`, computing each `fib4(n)` based on the sum of the four preceding values in the sequence. Finally, it returns the `n`-th element of the sequence.

This approach ensures that each element of the sequence is computed only once, resulting in a time complexity of O(n), which is significantly more efficient than the exponential time complexity of the naive recursive approach.