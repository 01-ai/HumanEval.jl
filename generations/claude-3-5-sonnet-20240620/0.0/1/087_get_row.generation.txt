Here's a Julia function that implements the described behavior:

```julia
function get_row(xs::Vector{Vector{Int}}, x::Int)::Vector{Tuple{Int, Int}}
    result = Tuple{Int, Int}[]
    
    for (row, vec) in enumerate(xs)
        columns = findall(==(x), vec)
        append!(result, [(row, col) for col in columns])
    end
    
    sort!(result, by = t -> (t[1], -t[2]))
    return result
end
```

Let's break down the function:

1. We initialize an empty vector `result` to store the tuples.

2. We iterate through the rows of `xs` using `enumerate` to get both the row index and the vector.

3. For each row, we use `findall(==(x), vec)` to get all column indices where the value equals `x`.

4. We create tuples of `(row, col)` for each found column and append them to `result`.

5. After processing all rows, we sort the `result`:
   - The primary sort is by the row (first element of the tuple) in ascending order.
   - The secondary sort is by the column (second element of the tuple) in descending order.
   We achieve this by using a custom sorting function `t -> (t[1], -t[2])`.

6. Finally, we return the sorted `result`.

This function handles all the given examples correctly:

```julia
julia> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)
5-element Vector{Tuple{Int64, Int64}}:
 (1, 1)
 (2, 5)
 (2, 1)
 (3, 6)
 (3, 1)

julia> get_row(Vector{Int}[], 1)
Tuple{Int64, Int64}[]

julia> get_row(Vector{Int}[Int[], [1], [1, 2, 3]], 3)
1-element Vector{Tuple{Int64, Int64}}:
 (3, 3)
```

The function correctly handles empty inputs, finds all occurrences of the given integer, and sorts the results as specified.