Here's a Julia function that solves the problem as described:

```julia
function fizz_buzz(n::Int)
    count = 0
    for i in 1:(n-1)
        if i % 11 == 0 || i % 13 == 0
            count += count_sevens(i)
        end
    end
    return count
end

function count_sevens(num::Int)
    return count(c -> c == '7', string(num))
end
```

Let's break down the solution:

1. We define the main function `fizz_buzz(n::Int)` that takes an integer `n` as input.

2. We initialize a `count` variable to keep track of the number of 7s found.

3. We iterate through all integers from 1 to `n-1`.

4. For each integer `i`, we check if it's divisible by 11 or 13 using the modulo operator `%`.

5. If the number is divisible by 11 or 13, we call a helper function `count_sevens(i)` to count the number of 7s in that integer and add it to our total `count`.

6. The `count_sevens` function converts the number to a string and uses Julia's `count` function to count the occurrences of the character '7'.

7. Finally, we return the total `count`.

This solution correctly handles the examples provided:

```julia
julia> fizz_buzz(50)
0

julia> fizz_buzz(78)
2

julia> fizz_buzz(79)
3
```

The function returns 0 for `fizz_buzz(50)` because there are no 7s in the numbers less than 50 that are divisible by 11 or 13.

For `fizz_buzz(78)`, it returns 2 because there are two 7s in the numbers less than 78 that are divisible by 11 or 13 (specifically, in the number 77, which is divisible by 11).

For `fizz_buzz(79)`, it returns 3 because it includes the additional 7 from the number 78 (which is divisible by 13).

This solution efficiently solves the problem for the given input range.