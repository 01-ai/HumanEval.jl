Here is a Julia function that implements the behavior described in the docstring:
```julia
function pairs_sum_to_zero(l::Vector{Int})::Bool
    seen = Set{Int}()
    for num in l
        if -num in seen
            return true
        end
        push!(seen, num)
    end
    return false
end
```
Here's an explanation of how the function works:

1. We create an empty set `seen` to keep track of the numbers we've seen so far.
2. We iterate over the input list `l`.
3. For each number `num` in the list, we check if its negation `-num` is already in the `seen` set. If it is, that means we've found two distinct elements that sum to zero, so we return `true`.
4. If `-num` is not in the `seen` set, we add `num` to the set and continue to the next iteration.
5. If we reach the end of the list without finding a pair of numbers that sum to zero, we return `false`.

This function has a time complexity of O(n), where n is the length of the input list, because we're doing a constant-time lookup in the `seen` set for each number in the list. The space complexity is also O(n) because in the worst case, we might need to store all numbers in the `seen` set.