Here's a Julia function that implements the described behavior:

```julia
function compare_one(a::Union{Integer, AbstractFloat, AbstractString}, 
                     b::Union{Integer, AbstractFloat, AbstractString})::Union{Integer, AbstractFloat, AbstractString, Nothing}
    
    # Convert strings to floats if necessary
    a_val = (a isa AbstractString) ? parse(Float64, replace(a, ',' => '.')) : a
    b_val = (b isa AbstractString) ? parse(Float64, replace(b, ',' => '.')) : b

    if a_val > b_val
        return a
    elseif b_val > a_val
        return b
    else
        return nothing
    end
end
```

This function does the following:

1. It takes two arguments `a` and `b`, which can be integers, floats, or strings.

2. For string inputs, it converts them to `Float64`:
   - It replaces any comma (`,`) with a dot (`.`) to handle different decimal separators.
   - It then parses the resulting string as a `Float64`.

3. For numeric inputs (integers or floats), it uses them as-is.

4. It compares the numeric values of `a` and `b`:
   - If `a` is greater, it returns `a` in its original type.
   - If `b` is greater, it returns `b` in its original type.
   - If they're equal, it returns `nothing`.

This function should work for all the example cases:

```julia
julia> compare_one(1, 2.5)
2.5

julia> compare_one(1, "2,3")
"2,3"

julia> compare_one("5,1", "6")
"6"

julia> compare_one("1", 1)
nothing
```

Note that this function will throw an error if the string inputs cannot be parsed as numbers. If you need to handle such cases, you might want to add error checking or use a try-catch block.