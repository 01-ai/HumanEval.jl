Here's a Julia function that implements the `find_zero` functionality as described:

```julia
function find_zero(xs::Vector{Int})
    # Check if the number of coefficients is even
    if length(xs) % 2 != 0
        error("The number of coefficients must be even")
    end
    
    # Check if the largest coefficient is non-zero
    if xs[end] == 0
        error("The largest coefficient must be non-zero")
    end
    
    # Define the polynomial function
    f(x) = poly(xs, x)
    
    # Define the derivative of the polynomial function
    function df(x)
        sum(coeff * (i - 1) * (x^(i - 2)) for (i, coeff) in enumerate(xs) if i > 1)
    end
    
    # Initial guess: start at x = 0
    x = 0.0
    
    # Newton's method
    for _ in 1:100  # Maximum 100 iterations
        fx = f(x)
        if abs(fx) < 1e-10  # Convergence criterion
            return x
        end
        dfx = df(x)
        if dfx == 0
            error("Derivative is zero. Cannot continue.")
        end
        x = x - fx / dfx
    end
    
    error("Failed to converge after 100 iterations")
end

# The poly function as given in the problem statement
poly(xs::Vector, x::Float64) = sum(coeff * (x^(i - 1)) for (i, coeff) in enumerate(xs))
```

This implementation uses Newton's method to find a zero of the polynomial. Here's how it works:

1. It first checks if the input satisfies the conditions (even number of coefficients and non-zero largest coefficient).

2. It defines the polynomial function `f(x)` using the given `poly` function.

3. It also defines the derivative function `df(x)` of the polynomial.

4. It starts with an initial guess of x = 0.

5. It then applies Newton's method: x_{n+1} = x_n - f(x_n) / f'(x_n)

6. It continues this process until either:
   - The absolute value of f(x) is very close to zero (less than 1e-10)
   - It has performed 100 iterations

7. If it finds a zero, it returns that value. If it fails to converge after 100 iterations, it throws an error.

This method should work for the given examples and many other polynomials. However, note that Newton's method can fail in some cases (e.g., if the initial guess is poor, or if the function has pathological behavior). For more robust root-finding, you might want to consider more advanced methods or libraries specifically designed for polynomial root-finding.