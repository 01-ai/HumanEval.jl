To solve this problem efficiently, we can use dynamic programming to avoid recalculating the same values multiple times. Here's a Julia function that implements this approach:

```julia
function fibfib(n::Int)::Int
    if n == 0 || n == 1
        return 0
    elseif n == 2
        return 1
    end

    a, b, c = 0, 0, 1
    for i in 3:n
        a, b, c = b, c, a + b + c
    end
    return c
end
```

This function first handles the base cases for `n = 0`, `n = 1`, and `n = 2`. For `n > 2`, it uses a loop to iteratively calculate the next value in the sequence by summing the previous three values. The loop updates the three variables `a`, `b`, and `c` to hold the last three values of the sequence at each step. After the loop, `c` holds the `n`-th value of the sequence, which is returned.

This implementation has a time complexity of O(n) and a space complexity of O(1), as it only uses a constant amount of space to store the last three values of the sequence.