To implement the `smallest_change` function, we need to determine the minimum number of changes required to make the given array palindromic. A palindromic array reads the same forwards and backwards. 

Here's a step-by-step approach to solve this problem:

1. **Identify Pairs**: For each element in the array, compare it with its corresponding element from the end of the array.
2. **Count Mismatches**: Count how many pairs of elements do not match.
3. **Return the Count**: The count of mismatches will be the minimum number of changes required to make the array palindromic.

Let's implement this in Julia:

```julia
function smallest_change(xs::Vector{Int})::Int
    n = length(xs)
    changes = 0
    for i in 1:div(n, 2)
        if xs[i] != xs[n - i + 1]
            changes += 1
        end
    end
    return changes
end
```

### Explanation:
- `n = length(xs)`: Get the length of the array.
- `changes = 0`: Initialize a counter for the number of changes.
- `for i in 1:div(n, 2)`: Loop through the first half of the array.
  - `if xs[i] != xs[n - i + 1]`: Compare the element at position `i` with the element at the corresponding position from the end.
    - If they are not equal, increment the `changes` counter.
- `return changes`: Return the total number of changes needed.

### Examples:
Let's test the function with the provided examples:

```julia
println(smallest_change([1, 2, 3, 5, 4, 7, 9, 6]))  # Output: 4
println(smallest_change([1, 2, 3, 4, 3, 2, 2]))    # Output: 1
println(smallest_change([1, 2, 3, 2, 1]))          # Output: 0
```

This function should correctly compute the minimum number of changes required to make the array palindromic.