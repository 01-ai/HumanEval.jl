 ```julia
"""
Evaluates polynomial with coefficients `xs` at point `x`. Return `xs[1] + xs[2]

  - x + xs[3] * x^2 + .... xs[n] * x^n`.
"""
function poly(xs::Vector, x::Float64)
    return sum(coeff * (x^(i - 1)) for (i, coeff) in enumerate(xs))
end

"""
    find_zero(xs::Vector{Int})

`xs` are coefficients of a polynomial. `find_zero` find `x` such that `poly(x) = 0`. `find_zero` returns only only zero point, even if there are many. Moreover,
`find_zero` only takes list xs having even number of coefficients and largest
non zero coefficient as it guarantees a solution.

# Examples

```jldoctest
julia> round(find_zero([1, 2]), digits = 1) # f(x) = 1 + 2x
-0.5

julia> round(find_zero([-6, 11, -6, 1]), digits = 1) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3
1.0
```
"""
function find_zero(xs::Vector{Int})
    # Ensure the number of coefficients is even
    if length(xs) % 2 != 0
        throw(ArgumentError("The number of coefficients must be even"))
    end

    # Ensure the largest non-zero coefficient is present
    if all(x -> x == 0, xs)
        throw(ArgumentError("All coefficients are zero"))
    end

    # Use the bisection method to find a zero
    function bisection(f, a, b, tol=1e-5, max_iter=1000)
        fa = f(a)
        fb = f(b)
        if fa * fb > 0
            throw(ArgumentError("The function must have different signs at the endpoints"))
        end

        for _ in 1:max_iter
            c = (a + b) / 2
            fc = f(c)
            if abs(fc) < tol
                return c
            elseif fa * fc < 0
                b = c
                fb = fc
            else
                a = c
                fa = fc
            end
        end
        throw(ErrorException("Failed to converge to a zero within the maximum number of iterations"))
    end

    # Define the polynomial function
    f(x) = poly(xs, x)

    # Initial guess for the interval [a, b]
    a = -10.0
    b = 10.0

    return bisection(f, a, b)
end
```