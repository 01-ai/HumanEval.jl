Here is a Julia function that implements the binary XOR operation on two input strings consisting of `1`s and `0`s:
```julia
function string_xor(a::String, b::String)::String
    # Check if input strings have the same length
    if length(a) != length(b)
        throw(ArgumentError("Input strings must have the same length"))
    end

    # Initialize an empty string to store the result
    result = ""

    # Iterate over the characters in the input strings
    for (char_a, char_b) in zip(a, b)
        # Check if characters are valid (either '0' or '1')
        if char_a ∉ ['0', '1'] || char_b ∉ ['0', '1']
            throw(ArgumentError("Input strings must only contain '0's and '1's"))
        end

        # Perform binary XOR operation
        xor_result = (char_a == '1') ⊻ (char_b == '1')

        # Append the result to the output string
        result *= xor_result ? "1" : "0"
    end

    return result
end
```
Here's an explanation of the code:

1. We first check if the input strings have the same length. If not, we throw an `ArgumentError`.
2. We initialize an empty string `result` to store the output.
3. We iterate over the characters in the input strings using the `zip` function, which returns an iterator over tuples of corresponding characters from each string.
4. For each pair of characters, we check if they are valid (either '0' or '1'). If not, we throw an `ArgumentError`.
5. We perform the binary XOR operation using the `⊻` operator, which returns `true` if the two operands are different and `false` otherwise.
6. We append the result of the XOR operation to the `result` string using the `*=` operator.
7. Finally, we return the `result` string.

You can test this function using the example provided in the docstring:
```julia
julia> string_xor("010", "110")
"100"
```