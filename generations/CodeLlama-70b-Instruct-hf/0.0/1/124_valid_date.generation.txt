
```julia
function valid_date(date::String)::Bool
    # Check if the date string is empty
    if date == ""
        return false
    end

    # Check if the date is in the correct format
    if !occursin(r"^\d{2}-\d{2}-\d{4}$", date)
        return false
    end

    # Split the date into day, month, and year
    date_parts = split(date, "-")
    month = parse(Int, date_parts[1])
    day = parse(Int, date_parts[2])
    year = parse(Int, date_parts[3])

    # Check if the month is valid
    if month < 1 || month > 12
        return false
    end

    # Check if the day is valid for the given month
    if month == 2
        if day < 1 || day > 29
            return false
        end
    elseif month in [4, 6, 9, 11]
        if day < 1 || day > 30
            return false
        end
    else
        if day < 1 || day > 31
            return false
        end
    end

    return true
end
```

This function first checks if the date string is empty. If it is, it returns `false`. Then, it checks if the date is in the correct format using a regular expression. If it is not, it returns `false`.

Next, it splits the date string into its three parts: month, day, and year. It then checks if the month is valid by checking if it is between 1 and 12. If it is not, it returns `false`.

Finally, it checks if the day is valid for the given month. If the month is February, it checks if the day is between 1 and 29. If the month is April, June, September, or November, it checks if the day is between 1 and 30. Otherwise, it checks if the day is between 1 and 31. If any of these checks fail, it returns `false`.

If all checks pass, it returns `true`.