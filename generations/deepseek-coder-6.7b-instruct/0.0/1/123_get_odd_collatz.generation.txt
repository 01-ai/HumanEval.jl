Here is the Julia function that implements the Collatz conjecture:

```julia
function get_odd_collatz(n::Int)::Vector{BigInt}
    # Initialize the list with the first number in the sequence
    collatz = BigInt[n]

    # Continue the sequence until we reach 1
    while n != 1
        # If the current number is even, divide it by 2
        if iseven(n)
            n = n ï¿½ 2
        # If the current number is odd, multiply it by 3 and add 1
        else
            n = 3n + 1
        end

        # If the new number is odd, add it to the list
        if isodd(n)
            push_odd(collatz, n)
        end
    end

    # Return the list sorted in increasing order
    return sort(collatz)
end

# Helper function to push an odd number to the list in the correct position
function push_odd(arr::Vector{BigInt}, n::BigInt)
    # Find the position where n should be inserted to keep the list sorted
    pos = searchsortedfirst(arr, n, by = x -> abs(x - n))

    # Insert n at the correct position
    insert_odd(arr, pos, n)
end

# Helper function to insert an odd number at a specific position in the list
function insert_odd(arr::Vector{BigInt}, pos::Int, n::BigInt)
    # If the list is not full, append n at the end
    if length(arr) < pos
        push_odd(arr, n)
    # If the list is full, insert n at the correct position
    else
        insert_odd(arr, pos, n)
    end
end
```

This function first initializes a list with the first number in the sequence. Then it continues the sequence until it reaches 1. If the current number is even, it is divided by 2. If it is odd, it is multiplied by 3 and 1 is added. The new number is only added to the list if it is odd. Finally, the list is returned sorted in increasing order.

The helper functions `push_odd` and `insert_odd` are used to insert an odd number at a specific position in the list, keeping the list sorted.
