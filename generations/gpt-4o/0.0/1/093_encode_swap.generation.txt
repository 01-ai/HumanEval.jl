Sure, let's implement the `encode_swap` function in Julia. The function will swap the case of all letters and replace all vowels with the letter that appears 2 places after that vowel in the English alphabet.

Here's the implementation:

```julia
function encode_swap(message::String)::String
    # Define a dictionary for vowel replacements
    vowel_replacement = Dict(
        'a' => 'c', 'e' => 'g', 'i' => 'k', 'o' => 'q', 'u' => 'w',
        'A' => 'C', 'E' => 'G', 'I' => 'K', 'O' => 'Q', 'U' => 'W'
    )
    
    # Initialize an empty string to store the encoded message
    encoded_message = ""
    
    # Iterate over each character in the message
    for char in message
        # Swap the case of the character
        if isuppercase(char)
            char = lowercase(char)
        else
            char = uppercase(char)
        end
        
        # Replace the vowel if it is in the dictionary
        if haskey(vowel_replacement, char)
            char = vowel_replacement[char]
        end
        
        # Append the modified character to the encoded message
        encoded_message *= char
    end
    
    return encoded_message
end
```

You can test the function with the provided examples:

```julia
println(encode_swap("test"))         # Output: "TGST"
println(encode_swap("This is a message"))  # Output: "tHKS KS C MGSSCGG"
```

This function works by first swapping the case of each character and then checking if the character is a vowel that needs to be replaced. If it is, it replaces the vowel with the corresponding character from the dictionary. Finally, it constructs the encoded message by appending each modified character.