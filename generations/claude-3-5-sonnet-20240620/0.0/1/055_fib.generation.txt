Here's a Julia function that calculates the n-th Fibonacci number based on the given specifications:

```julia
function fib(n::Int)::Int
    if n <= 0
        throw(ArgumentError("n must be a positive integer"))
    elseif n == 1 || n == 2
        return 1
    else
        a, b = 1, 1
        for _ in 3:n
            a, b = b, a + b
        end
        return b
    end
end
```

This implementation has the following characteristics:

1. It takes an integer `n` as input and returns an integer, as specified in the function signature.
2. It handles the base cases (n = 1 and n = 2) by returning 1.
3. For n > 2, it uses an iterative approach to calculate the Fibonacci number efficiently.
4. It throws an `ArgumentError` if n is not a positive integer.

The function should pass the given examples:

```julia
julia> fib(10)
55

julia> fib(1)
1

julia> fib(8)
21
```

This implementation has a time complexity of O(n) and a space complexity of O(1), making it efficient for calculating Fibonacci numbers for reasonably large values of n. However, for very large values of n, you might need to use a different approach or a big integer type to avoid integer overflow.