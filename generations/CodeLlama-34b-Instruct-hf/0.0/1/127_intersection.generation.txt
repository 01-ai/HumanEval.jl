  Here is a possible implementation of the `intersection` function in Julia:
```
function intersection(interval1::Vector{Int}, interval2::Vector{Int})::String
    # Check if the intervals intersect
    if interval1[1] > interval2[2] || interval1[2] < interval2[1]
        return "NO"
    end

    # Calculate the length of the intersection
    intersection_length = min(interval1[2], interval2[2]) - max(interval1[1], interval2[1])

    # Check if the length of the intersection is a prime number
    if isprime(intersection_length)
        return "YES"
    else
        return "NO"
    end
end
```
Here's an explanation of the code:

1. The function takes two arguments, `interval1` and `interval2`, which are vectors of integers representing the two intervals.
2. The first step is to check if the intervals intersect. This is done by checking if the start of one interval is greater than the end of the other interval, or if the end of one interval is less than the start of the other interval. If either of these conditions is true, then the intervals do not intersect and the function returns "NO".
3. If the intervals do intersect, the next step is to calculate the length of the intersection. This is done by taking the minimum of the endpoints of the two intervals and subtracting the maximum of the startpoints.
4. The final step is to check if the length of the intersection is a prime number. This is done using the `isprime` function, which returns true if the input is a prime number and false otherwise. If the length of the intersection is a prime number, the function returns "YES", otherwise it returns "NO".

Here are some examples of how the function can be used:
```
julia> intersection([1, 2], [2, 3])
"NO"

julia> intersection([-1, 1], [0, 4])
"NO"

julia> intersection([-3, -1], [-5, 5])
"YES"
```