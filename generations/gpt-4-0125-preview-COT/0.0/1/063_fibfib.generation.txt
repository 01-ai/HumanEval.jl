### Step-by-Step Outline

1. **Base Cases**: Handle the base cases for `n = 0`, `n = 1`, and `n = 2` directly in the function by returning their respective FibFib values according to the definition.

2. **Memoization Setup**: To avoid recomputation of the same values, set up a memoization technique. This involves creating a dictionary (or an array if you prefer, since the input is an integer) to store the computed values of `fibfib(n)`.

3. **Recursive Function with Memoization**:
    - If the value of `fibfib(n)` is already computed and stored in the memoization structure, return that value directly to save computation time.
    - Otherwise, compute `fibfib(n)` using the recursive formula `fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3)`, making sure to store the result in the memoization structure before returning it.

4. **Return the Result**: Finally, return the computed value of `fibfib(n)`.

### Julia Code Implementation

```julia
function fibfib(n::Int)::Int
    # Base cases directly defined
    if n == 0 || n == 1
        return 0
    elseif n == 2
        return 1
    end

    # Memoization setup
    memo = Dict(0 => 0, 1 => 0, 2 => 1)

    # Recursive function with memoization
    function fibfib_memo(n::Int, memo::Dict{Int,Int})::Int
        if haskey(memo, n)
            return memo[n]
        else
            memo[n] = fibfib_memo(n-1, memo) + fibfib_memo(n-2, memo) + fibfib_memo(n-3, memo)
            return memo[n]
        end
    end

    # Compute and return the result
    return fibfib_memo(n, memo)
end

# Examples to test the function
println(fibfib(1))  # Expected output: 0
println(fibfib(5))  # Expected output: 4
println(fibfib(8))  # Expected output: 24
```

This implementation uses memoization to efficiently compute the n-th element of the FibFib number sequence, avoiding the exponential time complexity that a naive recursive solution would have.