To implement the `sort_array` function as described, we need to sort the array based on two criteria:
1. The number of ones in the binary representation of each integer.
2. The decimal value of the integer itself, in case of a tie in the number of ones.

Here's how you can implement this in Julia:

```julia
"""
    sort_array(arr::Vector{Int})::Vector{Int}

In this Kata, you have to sort an array of non-negative integers according to
number of ones in their binary representation in ascending order. For similar
number of ones, sort based on decimal value.

# Examples

```jldoctest
julia> sort_array([1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5]
true

julia> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3]
true
```
"""
function sort_array(arr::Vector{Int})::Vector{Int}
    # Sort the array based on the number of ones in the binary representation
    # and then by the integer value itself in case of a tie.
    sort(arr, by = x -> (count_ones(x), x))
end
```

Explanation:
- `count_ones(x)` is a built-in Julia function that counts the number of ones in the binary representation of `x`.
- The `sort` function is used with the `by` keyword argument to specify a custom sorting criterion. The criterion is a tuple where the first element is the count of ones and the second element is the integer itself. This ensures that the array is sorted first by the number of ones and then by the integer value in case of a tie.

This implementation should meet the requirements specified in the doc string and pass the provided test cases.