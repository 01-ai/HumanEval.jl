Certainly! Below is the Julia function `min_sub_array_sum` that implements the functionality described in the doc string:

```julia
function min_sub_array_sum(nums::Vector{Int})::Int
    # Initialize the minimum sum to the first element and current sum to 0
    min_sum = nums[1]
    current_sum = 0
    
    # Iterate through the array
    for num in nums
        # If current sum is positive, it will only increase the sum of the sub-array,
        # so reset it to the current number if it's less than 0
        if current_sum > 0
            current_sum = num
        else
            current_sum += num
        end
        
        # Update the minimum sum if the current sum is less than the minimum sum
        min_sum = min(min_sum, current_sum)
    end
    
    return min_sum
end
```

You can use this function to find the minimum sum of any non-empty sub-array of an array of integers. Here's how you can use the function with the examples provided:

```julia
println(min_sub_array_sum([2, 3, 4, 1, 2, 4])) # Output should be 1
println(min_sub_array_sum([-1, -2, -3])) # Output should be -6
```

This function uses the Kadane's algorithm variant for finding the minimum sub-array sum, which is a dynamic programming approach. It iterates through the array, keeping track of the current sum and updating the minimum sum found so far. If the current sum becomes positive, it resets to the current element, as any positive sum would only increase the sum of a sub-array.