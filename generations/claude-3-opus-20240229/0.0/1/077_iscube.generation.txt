Here's a solution to the problem in Julia:

```julia
function iscube(a::Int)::Bool
    if a >= 0
        cbrt = round(a^(1/3))
        return cbrt^3 == a
    else
        cbrt = round((-a)^(1/3))
        return -cbrt^3 == a
    end
end
```

Explanation:

1. The function `iscube` takes an integer `a` as input and returns a boolean value indicating whether `a` is a cube of some integer number.

2. We first check if `a` is non-negative or negative.

3. If `a` is non-negative:
   - We calculate the cube root of `a` using `a^(1/3)` and round it to the nearest integer using `round()`. This gives us the potential integer cube root.
   - We then cube the rounded cube root using `cbrt^3` and compare it with the original input `a`. If they are equal, it means `a` is a cube of an integer number, and we return `true`. Otherwise, we return `false`.

4. If `a` is negative:
   - We calculate the cube root of the absolute value of `a` using `(-a)^(1/3)` and round it to the nearest integer using `round()`. This gives us the potential integer cube root.
   - We then cube the rounded cube root using `-cbrt^3` (since `a` is negative) and compare it with the original input `a`. If they are equal, it means `a` is a cube of an integer number, and we return `true`. Otherwise, we return `false`.

5. The function returns a boolean value (`true` or `false`) indicating whether `a` is a cube of some integer number.

Here are some example test cases and their outputs:

```jldoctest
julia> iscube(1)
true

julia> iscube(2)
false

julia> iscube(-1)
true

julia> iscube(64)
true

julia> iscube(0)
true

julia> iscube(180)
false
```

The solution handles both positive and negative integer inputs correctly and returns the expected boolean values.