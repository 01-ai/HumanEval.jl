Here is a Julia function that implements the given rules:

```julia
function valid_date(date::String)::Bool
    # Check if the date string is not empty
    if isempty(date)
        return false
    end

    # Split the date string into month, day, and year
    date_parts = split(date, '-')

    # Check if the date is in the format: mm-dd-yyyy
    if length(date_parts) != 3
        return false
    end

    # Convert the month, day, and year to integers
    month, day, year = tryparse.(Int, date_parts)

    # Check if the month, day, and year are valid
    if isnothing(month) || isnothing(day) || isnothing(year)
        return false
    end

    # Check if the month is valid
    if month < 1 || month > 12
        return false
    end

    # Check if the day is valid
    if day < 1 || day > 31
        return false
    end

    # Check if the day is valid for February
    if month == 2 && (day > 29 || (day == 29 && !isleapyear(year)))
        return false
    end

    # Check if the day is valid for April, June, September, and November
    if month in [4, 6, 9, 11] && day > 30
        return false
    end

    # If all checks pass, the date is valid
    return true
end
```

This function uses the `split` function to split the date string into month, day, and year parts. It then checks if the date is in the correct format and if the month, day, and year are valid. It also checks if the day is valid for February and April, June, September, and November. If all checks pass, the function returns `true`, otherwise it returns `false`.
