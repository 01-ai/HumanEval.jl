To efficiently compute the n-th element of the FibFib number sequence, we can use dynamic programming to avoid redundant calculations. Here's the implementation of the `fibfib` function in Julia:

```julia
function fibfib(n::Int)::Int
    if n == 0
        return 0
    elseif n == 1
        return 0
    elseif n == 2
        return 1
    end

    # Initialize an array to store the computed values
    fibfib_values = zeros(Int, n + 1)
    fibfib_values[1] = 0
    fibfib_values[2] = 0
    fibfib_values[3] = 1

    # Compute the values iteratively
    for i in 4:n+1
        fibfib_values[i] = fibfib_values[i-1] + fibfib_values[i-2] + fibfib_values[i-3]
    end

    return fibfib_values[n+1]
end
```

### Explanation:
1. **Base Cases**: We handle the base cases directly:
   - `fibfib(0) == 0`
   - `fibfib(1) == 0`
   - `fibfib(2) == 1`

2. **Dynamic Programming Array**: We use an array `fibfib_values` to store the computed values of the sequence up to `n`. This avoids redundant calculations and ensures efficient computation.

3. **Iterative Computation**: We fill the array iteratively from index 4 to `n+1` using the relation:
   - `fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3)`

4. **Return the Result**: Finally, we return the value at index `n+1` from the array.

### Example Usage:
```julia
println(fibfib(1))  # Output: 0
println(fibfib(5))  # Output: 4
println(fibfib(8))  # Output: 24
```

This implementation ensures that the function runs efficiently even for larger values of `n` by leveraging dynamic programming.