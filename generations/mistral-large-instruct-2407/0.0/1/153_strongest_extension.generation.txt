 Certainly! Below is the implementation of the `strongest_extension` function in Julia based on the given docstring:

```julia
"""
    strongest_extension(class_name::String, extensions::Vector{String})::String

You will be given the name of a class (a string) and a list of extensions. The
extensions are to be used to load additional classes to the class. The strength
of the extension is as follows: Let CAP be the number of the uppercase letters
in the extension"s name, and let SM be the number of lowercase letters in the
extension"s name, the strength is given by the fraction CAP - SM. You should
find the strongest extension and return a string in this format:
ClassName.StrongestExtensionName.

If there are two or more extensions with the same strength, you should choose
the one that comes first in the list.

# Examples

```jldoctest
julia> strongest_extension("Slices", ["SErviNGSliCes", "Cheese", "StuFfed"])  # "SErviNGSliCes" is the strongest extension since (its strength is -1)
"Slices.SErviNGSliCes"

julia> strongest_extension("my_class", ["AA", "Be", "CC"])
"my_class.AA"
```
"""
function strongest_extension(class_name::String, extensions::Vector{String})::String
    function calculate_strength(extension::String)::Int
        CAP = count(c -> isuppercase(c), extension)
        SM = count(c -> islowercase(c), extension)
        return CAP - SM
    end

    strongest_ext = extensions[1]
    max_strength = calculate_strength(strongest_ext)

    for ext in extensions
        strength = calculate_strength(ext)
        if strength > max_strength
            strongest_ext = ext
            max_strength = strength
        end
    end

    return "$class_name.$strongest_ext"
end
```

### Explanation:
1. **Function Definition**: The function `strongest_extension` takes two arguments: `class_name` (a string) and `extensions` (a vector of strings).
2. **Helper Function**: Inside the main function, a helper function `calculate_strength` is defined to calculate the strength of an extension. It counts the number of uppercase (`CAP`) and lowercase (`SM`) letters in the extension and returns the difference (`CAP - SM`).
3. **Initialization**: The variable `strongest_ext` is initialized to the first extension in the list, and `max_strength` is initialized to the strength of the first extension.
4. **Iteration**: The function iterates through the list of extensions, calculating the strength of each one. If an extension has a higher strength than the current `max_strength`, it updates `strongest_ext` and `max_strength`.
5. **Return**: Finally, the function returns a string in the format `ClassName.StrongestExtensionName`.

This implementation ensures that the strongest extension is found and returned in the required format.