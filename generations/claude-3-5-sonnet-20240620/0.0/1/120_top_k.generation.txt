Here's a Julia function that implements the `top_k` operation as described:

```julia
function top_k(xs::Vector{Int}, k::Int)::Vector{Int}
    # Check if k is valid
    if k < 0 || k > length(xs)
        throw(ArgumentError("k must be between 0 and the length of xs"))
    end

    # If k is 0, return an empty vector
    if k == 0
        return Int[]
    end

    # Sort the input vector in descending order
    sorted_xs = sort(xs, rev=true)

    # Return the first k elements
    return sorted_xs[1:k]
end
```

This implementation works as follows:

1. First, we check if `k` is valid (between 0 and the length of `xs`). If not, we throw an `ArgumentError`.

2. If `k` is 0, we return an empty vector of integers, as requested.

3. We sort the entire input vector `xs` in descending order using Julia's built-in `sort` function with the `rev=true` argument.

4. Finally, we return the first `k` elements of the sorted vector using array slicing.

This implementation meets all the requirements:

- It returns a `Vector{Int}` as specified in the function signature.
- The returned vector is sorted in descending order.
- It handles all cases where 0 ≤ k ≤ length(xs).
- It works correctly for the given examples and should work for any input within the specified ranges.

The time complexity of this solution is O(n log n) due to the sorting step, where n is the length of `xs`. While this might not be the most efficient solution for very large arrays, it's simple and works well for the given constraints (array length up to 1000).