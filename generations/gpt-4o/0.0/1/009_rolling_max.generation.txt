Sure, here is the implementation of the `rolling_max` function in Julia:

```julia
function rolling_max(numbers::Vector{Int})::Vector{Int}
    if isempty(numbers)
        return Int[]
    end

    max_so_far = numbers[1]
    result = [max_so_far]

    for i in 2:length(numbers)
        max_so_far = max(max_so_far, numbers[i])
        push!(result, max_so_far)
    end

    return result
end
```

This function iterates through the input list of integers, keeping track of the maximum value encountered so far and appending it to the result list. Here is how it works step-by-step:

1. Check if the input list is empty. If it is, return an empty list.
2. Initialize `max_so_far` with the first element of the input list.
3. Create a result list starting with the first element.
4. Iterate through the rest of the input list, updating `max_so_far` with the maximum value encountered so far.
5. Append the current `max_so_far` to the result list.
6. Return the result list.

You can test the function with the provided example:

```julia
println(rolling_max([1, 2, 3, 2, 3, 4, 2]))  # Output: [1, 2, 3, 3, 3, 4, 4]
```