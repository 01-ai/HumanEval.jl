  Here's an implementation of the `prod_signs` function in Julia:
```
function prod_signs(xs::Vector{Int})::Union{Nothing,Int}
    if isempty(xs)
        return nothing
    end
    signs = map(x -> x > 0 ? 1 : x < 0 ? -1 : 0, xs)
    return sum(abs.(xs)) * prod(signs)
end
```
Here's an explanation of the code:

1. The function takes a vector of integers `xs` as input and returns either an integer or `nothing` if the input is empty.
2. The first line checks if the input vector is empty. If it is, the function returns `nothing`.
3. The next line maps each element `x` in `xs` to its sign, which is either 1, -1, or 0 depending on whether `x` is positive, negative, or zero.
4. The `sum` function is used to calculate the sum of the magnitudes of the elements in `xs`.
5. The `prod` function is used to calculate the product of the signs of the elements in `xs`.
6. The final line returns the product of the sum of the magnitudes and the product of the signs.

Here are some examples of how the function works:

* `prod_signs([1, 2, 2, -4])` returns `-9`, which is the product of the sum of the magnitudes (`1 + 2 + 2 + (-4) = 5`) and the product of the signs (`1 * 1 * 1 * (-1) = -1`).
* `prod_signs([0, 1])` returns `0`, which is the product of the sum of the magnitudes (`0 + 1 = 1`) and the product of the signs (`0 * 1 = 0`).
* `prod_signs([])` returns `nothing`, which is the result of calling the function with an empty input vector.