Here's a Julia function that implements the `intersperse` behavior as described:

```julia
function intersperse(numbers::Vector{Int}, delimiter::Int)::Vector{Int}
    if isempty(numbers)
        return Int[]
    end
    
    result = Vector{Int}(undef, 2 * length(numbers) - 1)
    for i in 1:length(numbers)
        result[2i - 1] = numbers[i]
        if i < length(numbers)
            result[2i] = delimiter
        end
    end
    
    return result
end
```

This function does the following:

1. First, it checks if the input `numbers` is empty. If so, it returns an empty `Int` vector.

2. If `numbers` is not empty, it creates a new vector `result` with a size of `2 * length(numbers) - 1`. This is because we'll be inserting the delimiter between each pair of numbers, except after the last number.

3. It then iterates through the `numbers` vector:
   - For each number, it places it in the odd-indexed positions of `result`.
   - For each position except the last, it places the `delimiter` in the even-indexed positions.

4. Finally, it returns the `result` vector.

This implementation meets the requirements and produces the expected output for the given examples:

```julia
julia> intersperse(Int[], 4)
Int64[]

julia> intersperse([1, 2, 3], 4)
5-element Vector{Int64}:
 1
 4
 2
 4
 3
```

The function correctly handles both empty and non-empty input vectors, and inserts the delimiter between each pair of numbers in the input vector.