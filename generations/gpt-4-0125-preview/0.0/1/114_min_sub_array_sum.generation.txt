To solve this problem, we can use Kadane's algorithm with a slight modification to find the minimum sum sub-array instead of the maximum sum sub-array, which is what the algorithm is typically used for. Here's how you can implement the `min_sub_array_sum` function in Julia:

```julia
function min_sub_array_sum(nums::Vector{Int})::Int
    # Initialize current_sum and min_sum with the first element.
    current_sum = nums[1]
    min_sum = nums[1]

    # Iterate through the array starting from the second element.
    for i in 2:length(nums)
        # If current_sum is positive, it cannot contribute to a minimum sum,
        # so we start a new sub-array from the current element.
        # Otherwise, we add the current element to the current_sum.
        current_sum = min(nums[i], current_sum + nums[i])

        # Update min_sum if current_sum is smaller.
        min_sum = min(min_sum, current_sum)
    end

    return min_sum
end
```

This function iterates through the array once, maintaining a running sum (`current_sum`) that is reset to the current element if adding the current element would increase the sum (since we're looking for the minimum sum, not the maximum). The minimum sum found during the iteration is kept in `min_sum` and returned at the end. This approach ensures that the function runs in O(n) time, making it efficient even for large arrays.