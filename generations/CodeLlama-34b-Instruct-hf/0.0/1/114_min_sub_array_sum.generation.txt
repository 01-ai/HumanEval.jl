  Here's one possible implementation of the `min_sub_array_sum` function in Julia:
```
function min_sub_array_sum(nums::Vector{Int})::Int
    min_sum = typemax(Int)
    for i in 1:length(nums)
        for j in i:length(nums)
            sum = 0
            for k in i:j
                sum += nums[k]
            end
            min_sum = min(min_sum, sum)
        end
    end
    return min_sum
end
```
This function uses a nested loop to iterate over all possible sub-arrays of `nums`. For each sub-array, it calculates the sum of its elements and updates the minimum sum if necessary. The function returns the minimum sum found.

Here's an explanation of the code:

1. The function takes a vector of integers `nums` as input.
2. It initializes a variable `min_sum` to the maximum value of the `Int` type (i.e., `typemax(Int)`). This is the initial minimum sum that we will try to beat.
3. The outer loop iterates over all possible starting indices `i` of a sub-array.
4. The inner loop iterates over all possible ending indices `j` of a sub-array, given the starting index `i`.
5. For each sub-array, we calculate the sum of its elements using a nested loop that iterates over all elements between the starting and ending indices.
6. We update the minimum sum `min_sum` if the current sum is less than the previous minimum sum.
7. The function returns the minimum sum found.

Note that this implementation has a time complexity of O(n^3), where n is the length of the input array. This is because the outer loop has a time complexity of O(n), the inner loop has a time complexity of O(n), and the nested loop has a time complexity of O(n). However, the function is still efficient for small to medium-sized arrays.