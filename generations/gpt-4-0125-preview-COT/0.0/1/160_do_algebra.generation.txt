### Step-by-Step Outline

1. **Input Validation**: Ensure the `operator` list has one less element than the `operand` list, and both lists are not empty. Also, validate that all elements in the `operand` list are non-negative integers.

2. **Building the Expression**:
   - Initialize an empty string to build the algebraic expression.
   - Iterate through the `operand` and `operator` lists simultaneously, appending each operand and operator to the expression string. Since the `operator` list is one element shorter, append the last operand outside the loop.

3. **Evaluating the Expression**:
   - Use Julia's `Meta.parse()` to convert the expression string into an expression object.
   - Use `eval()` to evaluate the expression object and obtain the result.

4. **Return the Result**: Return the evaluated result from step 3.

### Julia Code Implementation

```julia
function do_algebra(operator::Vector{String}, operand::Vector{Int})
    # Step 1: Input Validation
    if length(operator) != length(operand) - 1 || isempty(operator) || isempty(operand)
        error("Invalid input: The length of operator list must be one less than the length of operand list.")
    end
    if any(x -> x < 0, operand)
        error("Invalid input: All operands must be non-negative integers.")
    end

    # Step 2: Building the Expression
    expression = ""
    for i in 1:length(operator)
        expression *= string(operand[i], " ", operator[i], " ")
    end
    expression *= string(operand[end])  # Append the last operand

    # Step 3: Evaluating the Expression
    expr = Meta.parse(expression)
    result = eval(expr)

    # Step 4: Return the Result
    return result
end
```

This implementation follows the outlined steps to build and evaluate the algebraic expression based on the given operators and operands. Note that using `eval()` can be risky if the input is not controlled, as it can execute arbitrary code. In this controlled scenario, it's assumed the inputs are safe.