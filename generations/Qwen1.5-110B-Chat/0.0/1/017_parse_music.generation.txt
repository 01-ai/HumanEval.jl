```julia
function parse_music(music_string::String)::Vector{Int}
    notes = ["o" => 4, "o|" => 2, ".|" => 1]
    return map(notes) do note
        count = 0
        for char in music_string
            if char == note
                count += notes[note]
            end
        end
        count
    end
end
```
However, this implementation doesn't follow the examples correctly. The function should parse the string and count the occurrences of each note pattern consecutively, not just count the total beats of each note type throughout the string. Let's correct it:

```julia
function parse_music(music_string::String)::Vector{Int}
    note_values = Dict("o" => 4, "o|" => 2, ".|" => 1)
    current_note = ""
    beats = Int[]
    
    for char in music_string
        if char == ' ' || char == '|'
            if current_note != ""
                push!(beats, note_values[current_note])
                current_note = ""
            end
        else
            current_note *= char
        end
    end
    
    if current_note != ""
        push!(beats, note_values[current_note])
    end
    
    return beats
end
```
This version correctly parses the string, identifies each note pattern, and calculates the beats for each note based on the consecutive pattern found in the string, according to the provided legend.