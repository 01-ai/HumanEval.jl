 Certainly! Below is the implementation of the `by_length` function in Julia based on the provided docstring:

```julia
"""
    by_length(xs::Vector{Int})::Vector{String}

Given an array of integers, sort the integers that are between 1 and 9
inclusive, reverse the resulting array, and then replace each digit by its
corresponding name from "One", "Two", "Three", "Four", "Five", "Six", "Seven",
"Eight", "Nine".

If the array is empty, return an empty array.

# Example

```jldoctest
julia> by_length([2, 1, 1, 4, 5, 8, 2, 3])  # sort & filtered: [1, 1, 2, 2, 3, 4, 5, 8], reversed: [8, 5, 4, 3, 2, 2, 1, 1]
8-element Vector{String}:
 "Eight"
 "Five"
 "Four"
 "Three"
 "Two"
 "Two"
 "One"
 "One"

julia> by_length(Int[])
String[]

julia> by_length([1, -1, 55])  # sorte & filtered: [1], reversed: [1]
1-element Vector{String}:
 "One"
```
"""
function by_length(xs::Vector{Int})::Vector{String}
    # Define the mapping from digits to their names
    digit_names = ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"]

    # Filter the integers between 1 and 9 inclusive
    filtered_xs = filter(x -> 1 <= x <= 9, xs)

    # Sort the filtered integers
    sorted_xs = sort(filtered_xs)

    # Reverse the sorted array
    reversed_xs = reverse(sorted_xs)

    # Replace each digit with its corresponding name
    result = [digit_names[x] for x in reversed_xs]

    return result
end
```

This function follows the steps outlined in the docstring:
1. Filters the integers to include only those between 1 and 9.
2. Sorts the filtered integers.
3. Reverses the sorted array.
4. Replaces each digit with its corresponding name from the `digit_names` array.
5. Returns the resulting array of strings.

You can test the function with the provided examples to ensure it works as expected.