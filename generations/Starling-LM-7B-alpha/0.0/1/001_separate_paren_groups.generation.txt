 Here's a Julia function that implements the desired functionality:

```julia
function separate_paren_groups(paren_string::String)::Vector{String}
    stack = []
    result = []
    current_group = ""

    for char in paren_string
        if char == '('
            push!(stack, current_group)
            current_group = ""
        elseif char == ')'
            if !isempty(current_group)
                current_group *= char
            else
                pop!(stack)
                current_group = ""
            end
        else
            current_group *= char
        end
    end

    if !isempty(current_group)
        push!(stack, current_group)
    end

    return stack
end
```

This function uses a stack to keep track of the current group of parentheses. It iterates through the input string, appending each character to the current group. When it encounters a closing parenthesis, it checks if the current group is empty. If it's not empty, it appends the closing parenthesis to the current group. If the current group is empty, it pops the last group from the stack. Finally, it returns the stack, which contains all the separated parentheses groups.

Here are some examples to demonstrate the function:

```jldoctest
julia> separate_paren_groups("( ) (( )) (( )( ))")
3-element Vector{String}:
 "()"
 "(())"
 "(()())"
```

As you can see, the function correctly separates the nested parentheses groups and returns them as a vector of strings.