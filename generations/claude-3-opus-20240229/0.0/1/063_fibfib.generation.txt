Here's an efficient implementation of the `fibfib` function in Julia:

```julia
function fibfib(n::Int)::Int
    if n <= 0
        return 0
    elseif n == 1
        return 0
    elseif n == 2
        return 1
    end

    fib = [0, 0, 1]
    for i in 4:n
        next_fib = fib[3] + fib[2] + fib[1]
        fib[1] = fib[2]
        fib[2] = fib[3]
        fib[3] = next_fib
    end

    return fib[3]
end
```

This implementation uses dynamic programming to efficiently compute the n-th element of the FibFib sequence. Here's how it works:

1. We first handle the base cases:
   - If `n` is less than or equal to 0, we return 0.
   - If `n` is equal to 1, we return 0.
   - If `n` is equal to 2, we return 1.

2. We initialize an array `fib` with the first three elements of the FibFib sequence: `[0, 0, 1]`.

3. We start a loop from 4 to `n`, where in each iteration:
   - We calculate the next FibFib number by summing the last three elements of the `fib` array.
   - We update the `fib` array by shifting the elements to the left and assigning the newly calculated FibFib number to `fib[3]`.

4. After the loop ends, the n-th FibFib number will be stored in `fib[3]`, which we return.

The time complexity of this implementation is O(n) since we iterate from 4 to `n` once. The space complexity is O(1) since we only use a constant amount of extra space for the `fib` array.

Here are some example outputs:

```jldoctest
julia> fibfib(1)
0

julia> fibfib(5)
4

julia> fibfib(8)
24
```

The function correctly computes the FibFib numbers for the given examples.