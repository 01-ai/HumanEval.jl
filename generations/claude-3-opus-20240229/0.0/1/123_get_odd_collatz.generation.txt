Here's the implementation of the `get_odd_collatz` function in Julia:

```julia
function get_odd_collatz(n::Int)::Vector{BigInt}
    sequence = BigInt[n]
    while n != 1
        if iseven(n)
            n = n รท 2
        else
            n = 3n + 1
        end
        push!(sequence, n)
    end
    return sort(filter(isodd, sequence))
end
```

Explanation:

1. We initialize a vector `sequence` with the starting value `n` as a `BigInt`.

2. We start a loop that continues until `n` becomes 1.

3. Inside the loop, we check if `n` is even using the `iseven` function:
   - If `n` is even, we divide it by 2 using integer division `รท`.
   - If `n` is odd, we multiply it by 3 and add 1.

4. We append the new value of `n` to the `sequence` vector using the `push!` function.

5. After the loop ends, we have the complete Collatz sequence stored in `sequence`.

6. We use the `filter` function with the `isodd` predicate to extract only the odd numbers from the `sequence`.

7. Finally, we sort the resulting vector of odd numbers in increasing order using the `sort` function and return it.

The function takes an integer `n` as input and returns a vector of `BigInt` values representing the odd numbers in the Collatz sequence starting from `n`.

The `BigInt` type is used to handle large integers and avoid overflow, as mentioned in the note.

The function satisfies the given examples and requirements:
- For `get_odd_collatz(5)`, it returns `[1, 5]`, which are the odd numbers in the Collatz sequence for 5.
- The returned list is sorted in increasing order.
- `BigInt` is used to handle large numbers and avoid overflow.